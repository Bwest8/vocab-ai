import { google } from '@ai-sdk/google';
import { generateObject } from 'ai';
import { GoogleGenAI } from '@google/genai';
import mime from 'mime';
import { mkdir, writeFile } from 'node:fs/promises';
import { randomUUID } from 'node:crypto';
import path from 'node:path';
import { z } from 'zod';
import type { GeminiVocabResponse } from './types';

// =============================================================================
// 1. Model Initialization & Configuration
// =============================================================================

// Initialize Gemini models for text/object generation (using AI SDK)
export const geminiFlash = google('models/gemini-flash-latest');
export const geminiImage = google('gemini-2.5-flash-image');

const GEMINI_IMAGE_MODEL_ID = 'gemini-2.5-flash-image';
const GEMINI_IMAGE_BASE_PATH = path.join(process.cwd(), 'public', 'vocab-sets');

let geminiImageClient: GoogleGenAI | null = null;

function getGeminiImageClient(): GoogleGenAI {
  const apiKey = process.env.GOOGLE_GENERATIVE_AI_API_KEY;

  if (!apiKey) {
    throw new Error('Missing GOOGLE_GENERATIVE_AI_API_KEY environment variable for Gemini image generation.');
  }

  if (!geminiImageClient) {
    geminiImageClient = new GoogleGenAI({ apiKey });
  }

  return geminiImageClient;
}

function sanitizeForFileName(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 40) || 'image';
}

export interface GenerateExampleImageParams {
  vocabSetId: string;
  exampleId: string;
  word: string;
  imageDescription: string;
  aspectRatio?: '1:1' | '16:9' | '4:3' | '3:4';
}

export interface GeneratedImageResult {
  publicUrl: string;
  absolutePath: string;
  fileName: string;
  mimeType: string;
}


// =============================================================================
// Helper for API Call with Backoff (Needed for image generation) 
// =============================================================================

/**
 * Executes a fetch request with exponential backoff for resilience against throttling.
 */
async function exponentialBackoffFetch(url: string, options: RequestInit, maxRetries = 5): Promise<Response> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.status !== 429 && response.ok) {
        return response;
      }
      if (response.status === 429 || !response.ok) {
        // Attempt retry after backoff
      } else {
        return response; // Success or non-retryable error
      }
    } catch (error) {
      // Fetch attempt failed (e.g., network error). Retrying...
    }

    if (i < maxRetries - 1) {
      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s, 8s, 16s
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  throw new Error(`API call failed after ${maxRetries} attempts.`);
}

// =============================================================================
// 2. AI Generation Functions (Text/Object)
// =============================================================================

/**
 * Process vocabulary words using Gemini AI.
 * Generates definition, part of speech, example sentence, and a simple image prompt.
 * @param word The vocabulary word to process.
 * @returns An object containing the word details generated by the model.
 */
export async function processVocabularyWord(word: string) {
  const schema = z.object({
    word: z.string(),
    definition: z.string().describe('Clear, child-friendly definition'),
    partOfSpeech: z.string().describe('Part of speech: noun, verb, adjective, etc.'),
    exampleSentence: z.string().describe('Simple example sentence using the word'),
    imagePrompt: z.string().describe('Detailed prompt for generating a whimsical, child-friendly illustration'),
  });

  const result = await generateObject({
    model: geminiFlash,
    schema,
    prompt: `You are an elementary school teacher creating vocabulary learning materials.
For the word "${word}", provide:
1. A clear, age-appropriate definition (suitable for grades 3-5)
2. The part of speech
3. A simple, engaging example sentence
4. A detailed image prompt for generating a whimsical cartoon illustration that visually represents the word

The image prompt should describe a bright, colorful, child-friendly scene that clearly illustrates the word's meaning. Include details about:
- The main subject/action
- Colors and style (whimsical, cartoon-like)
- Composition (simple, focused)

Make everything engaging and memorable for elementary students.`,
  });

  return result.object;
}

/**
 * Process a vocabulary word with comprehensive details including multiple examples.
 * Uses a structured JSON schema for detailed output.
 * @param word The vocabulary word to process.
 * @returns A structured object conforming to GeminiVocabResponse.
 */
export async function processVocabularyWordWithExamples(word: string): Promise<GeminiVocabResponse> {
  const schema = z.object({
    WORD: z.string(),
    DEFINITION: z.string().describe('A clear, concise, student-friendly definition in one sentence'),
    PRONUNCIATION: z.string().describe('Phonetic pronunciation guide, e.g., /ˈraɪ.vəl/'),
    PART_OF_SPEECH: z.string().describe('noun | verb | adjective | adverb | etc.'),
    EXAMPLES: z.array(
      z.object({
        sentence: z.string().describe('Kid-friendly example sentence'),
        image_description: z.string().describe('Child-friendly illustration idea based on this sentence'),
      })
    ).length(5),
  });

  const result = await generateObject({
    model: geminiFlash,
    schema,
    prompt: `You are a vocabulary learning assistant. For the word "${word}", return a structured JSON object.

Guidelines:
- Keep definitions and pronunciations short but accurate.
- Sentences should be natural, simple, and relatable for children (ages 8-12).
- Image descriptions should be concrete and visual, directly tied to each example sentence.
- Provide exactly 5 distinct examples.
- Ensure the output is valid JSON.`,
  });

  return result.object as GeminiVocabResponse;
}

// =============================================================================
// 3. AI Generation Functions (Image)
// =============================================================================

/**
 * Generates and persists an example illustration for a vocabulary word.
 * Leverages the gemini-2.5-flash-image model, storing the resulting file under
 * `public/vocab-sets/{setId}/` so it can be served statically by Next.js.
 */

export async function generateExampleImage({
  vocabSetId,
  exampleId,
  word,
  imageDescription,
  aspectRatio = '1:1',
}: GenerateExampleImageParams): Promise<GeneratedImageResult> {
  if (!imageDescription?.trim()) {
    throw new Error('Image description is required to generate an illustration.');
  }

  const client = getGeminiImageClient();

  const enhancedPrompt = enhanceImagePrompt(imageDescription.trim(), word);

  const stream = await client.models.generateContentStream({
    model: GEMINI_IMAGE_MODEL_ID,
    contents: [
      {
        role: 'user',
        parts: [{ text: enhancedPrompt }],
      },
    ],
    config: {
      responseModalities: ['IMAGE'],
      imageConfig: {
        aspectRatio,
      },
    },
  });

  const imageParts: Array<{ buffer: Buffer; mimeType: string }> = [];

  for await (const chunk of stream as AsyncIterable<unknown>) {
    const candidates = (chunk as any)?.candidates ?? [];

    for (const candidate of candidates) {
      const parts = candidate?.content?.parts ?? [];

      for (const part of parts) {
        const inlineData = part?.inlineData;
        if (inlineData?.data) {
          const mimeType = inlineData?.mimeType ?? 'image/png';
          imageParts.push({
            buffer: Buffer.from(inlineData.data, 'base64'),
            mimeType,
          });
        }
      }
    }
  }

  if (imageParts.length === 0) {
    throw new Error('Gemini did not return any inline image data.');
  }

  const { buffer, mimeType } = imageParts[0];
  const extension = mime.getExtension(mimeType) ?? 'png';

  const setFolder = path.join(GEMINI_IMAGE_BASE_PATH, vocabSetId);
  await mkdir(setFolder, { recursive: true });

  const safeWord = sanitizeForFileName(word);
  const fileName = `${safeWord}-${exampleId}-${randomUUID()}.${extension}`;
  const absolutePath = path.join(setFolder, fileName);

  await writeFile(absolutePath, buffer);

  const publicUrl = `/vocab-sets/${vocabSetId}/${fileName}`;

  return {
    publicUrl,
    absolutePath,
    fileName,
    mimeType,
  };
}



// =============================================================================
// 4. Utility Functions
// =============================================================================

/**
 * Parse raw vocab text input into individual words.
 * Handles various formats from teachers/parents (e.g., numbered lists, optional part of speech).
 * @param rawText The raw text input containing vocabulary words.
 * @returns An array of objects with parsed word, partOfSpeech, and optional definition.
 */
export function parseVocabText(rawText: string): Array<{ word: string; partOfSpeech?: string; definition?: string }> {
  const lines = rawText.trim().split('\n');
  const words: Array<{ word: string; partOfSpeech?: string; definition?: string }> = [];

  let currentWord: { word: string; partOfSpeech?: string; definition?: string } | null = null;

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) continue;

    // Match patterns like "1. Aspiring adj." or "2. Rival"
    const wordMatch = trimmedLine.match(/^\d+\.\s+([A-Za-z]+)(?:\s+(adj\.|n\.|v\.|adv\.))?/i);

    if (wordMatch) {
      // Save previous word if exists
      if (currentWord) {
        words.push(currentWord);
      }

      // Start new word
      currentWord = {
        word: wordMatch[1].trim(),
        partOfSpeech: wordMatch[2]?.replace('.', '').trim(),
      };
    } else if (currentWord && trimmedLine && !trimmedLine.match(/^\d+\./)) {
      // This is part of the definition (optional, we'll regenerate with AI anyway)
      if (!currentWord.definition) {
        currentWord.definition = trimmedLine;
      } else {
        currentWord.definition += ' ' + trimmedLine;
      }
    }
  }

  // Don't forget the last word
  if (currentWord) {
    words.push(currentWord);
  }

  return words;
}

/**
 * Generate image prompt enhancement by adding style and format constraints for generation.
 * @param basePrompt The core description from the AI model.
 * @param word The word itself, to be included in the image.
 * @returns The final, enhanced image generation prompt string.
 */
export function enhanceImagePrompt(basePrompt: string, word: string): string {
  return `Create a whimsical, cartoon-style illustration: ${basePrompt}.
Use bright, vibrant colors and a simple, clean composition.
The style should be child-friendly and engaging, similar to children's book illustrations.
Include the word "${word.toUpperCase()}" prominently displayed at the bottom of the image in large, bold, easy-to-read letters.
The image should be square (1024x1024), with the main subject centered and clearly visible.`;
}

/**
 * Generate quiz question objects with distractors (multiple choice).
 * @param word The correct answer word.
 * @param definition The definition to use as the question text.
 * @param allWords An array of all possible words to pull distractors from.
 * @returns An object containing the question, correct answer, and shuffled choices.
 */
export async function generateQuizQuestion(
  word: string,
  definition: string,
  allWords: string[]
) {
  const otherWords = allWords.filter(w => w.toLowerCase() !== word.toLowerCase());

  // Randomly select 3 wrong answers
  const shuffled = otherWords.sort(() => 0.5 - Math.random());
  const wrongAnswers = shuffled.slice(0, 3);

  // Combine and shuffle all answers
  const allAnswers = [word, ...wrongAnswers].sort(() => 0.5 - Math.random());

  return {
    question: definition,
    correctAnswer: word,
    choices: allAnswers,
  };
}

/**
 * Get random words for matching game.
 * Shuffles the provided array for pairing.
 * @param words An array of word objects to shuffle.
 * @returns The shuffled array of word objects.
 */
export function generateMatchingPairs(words: Array<{ word: string; definition: string; imageUrl?: string }>) {
  // Shuffle and return all words for matching
  return words.sort(() => 0.5 - Math.random());
}

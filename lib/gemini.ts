import { google } from '@ai-sdk/google';
import { generateObject } from 'ai';
import { z } from 'zod';
import type { GeminiVocabResponse } from './types';

// =============================================================================
// 1. Model Initialization & Configuration
// =============================================================================

// Initialize Gemini models for text/object generation (using AI SDK)
export const geminiFlash = google('models/gemini-flash-latest');
export const geminiPro = google('gemini-1.5-pro-latest');

// Configuration for image generation API (gemini-2.5-flash-image-preview)
const IMAGE_API_KEY = ""; // Placeholder for Canvas environment key
const IMAGE_MODEL = "gemini-2.5-flash-image-preview";
const IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${IMAGE_MODEL}:generateContent?key=${IMAGE_API_KEY}`;


// =============================================================================
// Helper for API Call with Backoff (Needed for image generation) 
// =============================================================================

/**
 * Executes a fetch request with exponential backoff for resilience against throttling.
 */
async function exponentialBackoffFetch(url: string, options: RequestInit, maxRetries = 5): Promise<Response> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.status !== 429 && response.ok) {
        return response;
      }
      if (response.status === 429 || !response.ok) {
        // Attempt retry after backoff
      } else {
        return response; // Success or non-retryable error
      }
    } catch (error) {
      // Fetch attempt failed (e.g., network error). Retrying...
    }

    if (i < maxRetries - 1) {
      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s, 8s, 16s
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  throw new Error(`API call failed after ${maxRetries} attempts.`);
}

// =============================================================================
// 2. AI Generation Functions (Text/Object)
// =============================================================================

/**
 * Process vocabulary words using Gemini AI.
 * Generates definition, part of speech, example sentence, and a simple image prompt.
 * @param word The vocabulary word to process.
 * @returns An object containing the word details generated by the model.
 */
export async function processVocabularyWord(word: string) {
  const schema = z.object({
    word: z.string(),
    definition: z.string().describe('Clear, child-friendly definition'),
    partOfSpeech: z.string().describe('Part of speech: noun, verb, adjective, etc.'),
    exampleSentence: z.string().describe('Simple example sentence using the word'),
    imagePrompt: z.string().describe('Detailed prompt for generating a whimsical, child-friendly illustration'),
  });

  const result = await generateObject({
    model: geminiFlash,
    schema,
    prompt: `You are an elementary school teacher creating vocabulary learning materials.
For the word "${word}", provide:
1. A clear, age-appropriate definition (suitable for grades 3-5)
2. The part of speech
3. A simple, engaging example sentence
4. A detailed image prompt for generating a whimsical cartoon illustration that visually represents the word

The image prompt should describe a bright, colorful, child-friendly scene that clearly illustrates the word's meaning. Include details about:
- The main subject/action
- Colors and style (whimsical, cartoon-like)
- Composition (simple, focused)

Make everything engaging and memorable for elementary students.`,
  });

  return result.object;
}

/**
 * Process a vocabulary word with comprehensive details including multiple examples.
 * Uses a structured JSON schema for detailed output.
 * @param word The vocabulary word to process.
 * @returns A structured object conforming to GeminiVocabResponse.
 */
export async function processVocabularyWordWithExamples(word: string): Promise<GeminiVocabResponse> {
  const schema = z.object({
    WORD: z.string(),
    DEFINITION: z.string().describe('A clear, concise, student-friendly definition in one sentence'),
    PRONUNCIATION: z.string().describe('Phonetic pronunciation guide, e.g., /ˈraɪ.vəl/'),
    PART_OF_SPEECH: z.string().describe('noun | verb | adjective | adverb | etc.'),
    EXAMPLES: z.array(
      z.object({
        sentence: z.string().describe('Kid-friendly example sentence'),
        image_description: z.string().describe('Child-friendly illustration idea based on this sentence'),
      })
    ).length(5),
  });

  const result = await generateObject({
    model: geminiFlash,
    schema,
    prompt: `You are a vocabulary learning assistant. For the word "${word}", return a structured JSON object.

Guidelines:
- Keep definitions and pronunciations short but accurate.
- Sentences should be natural, simple, and relatable for children (ages 8-12).
- Image descriptions should be concrete and visual, directly tied to each example sentence.
- Provide exactly 5 distinct examples.
- Ensure the output is valid JSON.`,
  });

  return result.object as GeminiVocabResponse;
}

// =============================================================================
// 3. AI Generation Functions (Image)
// =============================================================================

/**
 * Generates an image from a detailed prompt using the gemini-2.5-flash-image-preview model.
 * @param prompt The detailed image generation prompt.
 * @returns A data URL string for the generated image (e.g., 'data:image/png;base64,...').
 */
export async function generateImageFromPrompt(prompt: string): Promise<string> {
    const payload = {
        contents: [{
            parts: [{ text: prompt }]
        }],
        generationConfig: {
            responseModalities: ['IMAGE']
        },
    };

    const options: RequestInit = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    };

    try {
        const response = await exponentialBackoffFetch(IMAGE_API_URL, options);
        const result = await response.json();

        // Extract base64 image data
        const base64Data = result?.candidates?.[0]?.content?.parts?.find((p: any) => p.inlineData)?.inlineData?.data;

        if (!base64Data) {
            console.error("Image generation failed or returned no base64 data:", result);
            throw new Error("Failed to generate image data.");
        }

        return `data:image/png;base64,${base64Data}`;

    } catch (error) {
        // Throw an error that can be caught by the caller
        throw new Error("Image generation failed.");
    }
}


// =============================================================================
// 4. Utility Functions
// =============================================================================

/**
 * Parse raw vocab text input into individual words.
 * Handles various formats from teachers/parents (e.g., numbered lists, optional part of speech).
 * @param rawText The raw text input containing vocabulary words.
 * @returns An array of objects with parsed word, partOfSpeech, and optional definition.
 */
export function parseVocabText(rawText: string): Array<{ word: string; partOfSpeech?: string; definition?: string }> {
  const lines = rawText.trim().split('\n');
  const words: Array<{ word: string; partOfSpeech?: string; definition?: string }> = [];

  let currentWord: { word: string; partOfSpeech?: string; definition?: string } | null = null;

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) continue;

    // Match patterns like "1. Aspiring adj." or "2. Rival"
    const wordMatch = trimmedLine.match(/^\d+\.\s+([A-Za-z]+)(?:\s+(adj\.|n\.|v\.|adv\.))?/i);

    if (wordMatch) {
      // Save previous word if exists
      if (currentWord) {
        words.push(currentWord);
      }

      // Start new word
      currentWord = {
        word: wordMatch[1].trim(),
        partOfSpeech: wordMatch[2]?.replace('.', '').trim(),
      };
    } else if (currentWord && trimmedLine && !trimmedLine.match(/^\d+\./)) {
      // This is part of the definition (optional, we'll regenerate with AI anyway)
      if (!currentWord.definition) {
        currentWord.definition = trimmedLine;
      } else {
        currentWord.definition += ' ' + trimmedLine;
      }
    }
  }

  // Don't forget the last word
  if (currentWord) {
    words.push(currentWord);
  }

  return words;
}

/**
 * Generate image prompt enhancement by adding style and format constraints for generation.
 * @param basePrompt The core description from the AI model.
 * @param word The word itself, to be included in the image.
 * @returns The final, enhanced image generation prompt string.
 */
export function enhanceImagePrompt(basePrompt: string, word: string): string {
  return `Create a whimsical, cartoon-style illustration: ${basePrompt}.
Use bright, vibrant colors and a simple, clean composition.
The style should be child-friendly and engaging, similar to children's book illustrations.
Include the word "${word.toUpperCase()}" prominently displayed at the bottom of the image in large, bold, easy-to-read letters.
The image should be square (1024x1024), with the main subject centered and clearly visible.`;
}

/**
 * Generate quiz question objects with distractors (multiple choice).
 * @param word The correct answer word.
 * @param definition The definition to use as the question text.
 * @param allWords An array of all possible words to pull distractors from.
 * @returns An object containing the question, correct answer, and shuffled choices.
 */
export async function generateQuizQuestion(
  word: string,
  definition: string,
  allWords: string[]
) {
  const otherWords = allWords.filter(w => w.toLowerCase() !== word.toLowerCase());

  // Randomly select 3 wrong answers
  const shuffled = otherWords.sort(() => 0.5 - Math.random());
  const wrongAnswers = shuffled.slice(0, 3);

  // Combine and shuffle all answers
  const allAnswers = [word, ...wrongAnswers].sort(() => 0.5 - Math.random());

  return {
    question: definition,
    correctAnswer: word,
    choices: allAnswers,
  };
}

/**
 * Get random words for matching game.
 * Shuffles the provided array for pairing.
 * @param words An array of word objects to shuffle.
 * @returns The shuffled array of word objects.
 */
export function generateMatchingPairs(words: Array<{ word: string; definition: string; imageUrl?: string }>) {
  // Shuffle and return all words for matching
  return words.sort(() => 0.5 - Math.random());
}
